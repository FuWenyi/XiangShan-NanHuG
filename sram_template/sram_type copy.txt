io    word  num  sp     sram type 
(50,  128)  16          -> (64, 128)        Folded1
(261, 4)    4           -> 2 * (144, 8)     PTl2
(512, 32)   8           -> 4 * (128, 32)    ICache Data
(7,   128)  4           -> (8, 128)         L3 Meta
(12,  256)  64          -> (16, 256)        Folded
(3,   128)  1           -> (8, 128)         L3 Replace
(26,  32)   8           -> (32, 32)         ICache Tag
(64,  128)  32          -> (64, 128)        L3 Wrap
(64,  64)   64          -> (64, 64)         DCache Data
(512, 12)   1    F      -> 4 * (128, 16)    Ftq1
(2,   2048) 2    F      -> 4 * (2, 512)     BigTable
(80,  64)   4           -> (80, 64)         Ftb
(23,  128)  4           -> (32, 128)        L3 Tag
(334, 4)    8           -> 3 * (128, 8)     PTl3
(1,   256)  64          -> 2 * (8, 128)     Folded
(24,  64)   34          -> (32, 64)         L3 Tag / DCache Tag
(233, 12)   3    F      -> 2 * (128, 16)    Ftq2
(4,   64)   10          -> (8, 64)          L3 Meta


icache 16 4 dcache 32 8 l3 32 8
io    word  num  sp     sram type 
(50,  128)  16          -> (64, 128)        Folded_1(ok)   TS5N28HPCPLVTA128X64M2F
(261, 4)    4           -> 2 * (144, 8)     PTl2
(512, 32)   8           -> 4 * (128, 32)    ICache Data
(7,   64)   9           -> (8, 64)          L3 Meta_1(ok) / L3 Replace(ok)
(12,  256)  64          -> (16, 256)        Folded_3(ok)
(26,  32)   8           -> (32, 32)         ICache Tag(ok)  TS5N28HPCPLVTA32X32M2F
(64,  128)  32          -> (64, 128)        L3 Wrap(ok)
(64,  64)   64          -> (64, 64)         DCache Data(ok)  TS5N28HPCPLVTA64X64M2F
(512, 12)   1    F      -> 4 * (128, 16)    Ftq_2
(2,   2048) 2    F      -> 4 * (2, 512)     BigTable
(80,  64)   4           -> (80, 64)         Ftb(ok)
(334, 4)    8           -> 3 * (128, 8)     PTl3
(1,   256)  64          -> 2 * (8, 128)     Folded_2
(24,  64)   42          -> (32, 64)         L3 Tag(ok) / DCache Tag(ok)
(233, 12)   3    F      -> 2 * (128, 16)    Ftq_1
(4,   64)   10          -> (8, 64)          L3 Meta_2(ok)

  val io = IO(new Bundle {
    val r = Flipped(new SRAMReadBus(gen, set, way))
    val w = Flipped(new SRAMWriteBus(gen, set, way))
  })
  val extra_reset = if (extraReset) Some(IO(Input(Bool()))) else None

  val wordType = UInt(gen.getWidth.W)
  val sram = Seq.fill(way)(Module(new TS5N28HPCPLVTA128X64M2F()))
  val (resetState, resetSet) = (WireInit(false.B), WireInit(0.U))

  if (shouldReset) {
    val _resetState = RegInit(true.B)
    val (_resetSet, resetFinish) = Counter(_resetState, set)
    when (resetFinish) { _resetState := false.B }
    if (extra_reset.isDefined) {
      when (extra_reset.get) {
        _resetState := true.B
      }
    }

    resetState := _resetState
    resetSet := _resetSet
  }

  val (ren, wen) = (io.r.req.valid, io.w.req.valid || resetState)
  val realRen = (if (singlePort) ren && !wen else ren)

  val setIdx = Mux(resetState, resetSet, io.w.req.bits.setIdx)
  val wdata = VecInit(Mux(resetState, 0.U.asTypeOf(Vec(way, gen)), io.w.req.bits.data).map(_.asTypeOf(wordType)))
  val waymask = Mux(resetState, Fill(way, "b1".U), io.w.req.bits.waymask.getOrElse("b1".U))
  sram.map(_.CLK := clock)
  sram.map(_.A := Mux(wen, setIdx, io.r.req.bits.setIdx))
  sram.zipWithIndex.map{
    case (s, i) => s.CEB := ~(wen || realRen)
  }
  sram.zipWithIndex.map{
    case (s, i) => s.WEB := ~(wen && OHToUInt(io.w.req.bits.waymask.getOrElse("b0".U)) === i.U)
  }
  sram.map(_.D := wdata.asUInt)

  val Rdata = VecInit(sram.map(_.Q))

  // bypass for dual-port SRAMs
  require(!bypassWrite || bypassWrite && !singlePort)
  def need_bypass(wen: Bool, waddr: UInt, wmask: UInt, ren: Bool, raddr: UInt) : UInt = {
    val need_check = RegNext(ren && wen)
    val waddr_reg = RegNext(waddr)
    val raddr_reg = RegNext(raddr)
    require(wmask.getWidth == way)
    val bypass = Fill(way, need_check && waddr_reg === raddr_reg) & RegNext(wmask)
    bypass.asTypeOf(UInt(way.W))
  }
  val bypass_wdata = if (bypassWrite) VecInit(RegNext(io.w.req.bits.data).map(_.asTypeOf(wordType)))
    else VecInit((0 until way).map(_ => LFSR64().asTypeOf(wordType)))
  val bypass_mask = need_bypass(io.w.req.valid, io.w.req.bits.setIdx, io.w.req.bits.waymask.getOrElse("b1".U), io.r.req.valid, io.r.req.bits.setIdx)
  val mem_rdata = {
    if (singlePort) Rdata
    else VecInit(bypass_mask.asBools.zip(Rdata).zip(bypass_wdata).map {
      case ((m, r), w) => Mux(m, w, r)
    })
  }

  // hold read data for SRAMs
  val rdata = (if (holdRead) HoldUnless(mem_rdata, RegNext(realRen))
              else mem_rdata).map(_.asTypeOf(gen))

  io.r.resp.data := VecInit(rdata)
  io.r.req.ready := !resetState && (if (singlePort) !wen else true.B)
  io.w.req.ready := true.B